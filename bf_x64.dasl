--go @ luajit dynasm.lua -o bf_compiler.lua *
--brainfuck example adapted from http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html
--requires DynASM with Lua mode from http://luapower/dynasm
local ffi = require'ffi'
local dasm = require'dasm'

ffi.cdef[[
int getchar (void);
int putchar (int character);
]]

|.arch x64
|.actionlist actions
|
|// Use rbx as our cell pointer.
|// Since rbx is a callee-save register, it will be preserved
|// across our calls to getchar and putchar.
|.define PTR, rbx
|
|// Macro for calling a function.
|// In cases where our target is <=2**32 away we can use
|//   | call &addr
|// But since we don't know if it will be, we use this safe
|// sequence instead.
|.macro callp, addr
|  mov64  rax, ffi.cast("uintptr_t", ffi.C.addr)
|  call   rax
|.endmacro

local function compile(program)

	local Dst = dasm.new(actions)

	local MAX_NESTING = 256

	local maxpc = 0
	local pcstack = ffi.new('int[?]', MAX_NESTING)
	local top   = ffi.cast('int*', pcstack)
	local limit = ffi.cast('int*', pcstack) + MAX_NESTING

	-- Function prologue.
	|  push PTR
	|  mov  PTR, [esp+4]

	for c in string.gmatch(program, '.') do
		if c == '>' then
			|  inc  PTR
		elseif c == '<' then
			|  dec  PTR
		elseif c == '+' then
			|  inc  byte [PTR]
		elseif c == '-' then
			|  dec  byte [PTR]
		elseif c == '.' then
			|  movzx edi, byte [PTR]
			|  callp putchar
		elseif c == ',' then
			|  callp getchar
			|  mov   byte [PTR], al
		elseif c == '[' then
			if top == limit then err("Nesting too deep.") end
			-- Each loop gets two pclabels: at the beginning and end.
			-- We store pclabel offsets in a stack to link the loop
			-- begin and end together.
			maxpc = maxpc + 2
			top[0] = maxpc
			top = top + 1
			Dst:growpc(maxpc)
			|  cmp  byte [PTR], 0
			|  je   =>(maxpc-2)
			|=>(maxpc-1):
		elseif c == ']' then
			if top == pcstack then err("Unmatched ']'") end
			top = top - 1
			|  cmp  byte [PTR], 0
			|  jne  =>(top[0]-1)
			|=>(top[0]-2):
		end
	end

	-- Function epilogue.
	|  pop  PTR
	|  ret

	local buf, sz = Dst:build()
	local fptr = ffi.cast('void (*)(char*)', buf)

	local function program(mem)
		local _ = buf --pin it
		mem = mem or 64*1024
		if type(mem) == 'number' then
			mem = ffi.new('uint8_t[?]', mem)
		end
		fptr(mem)
		return mem
	end

	return program, buf, sz
end

return {compile = compile}

