--go@ luajit dynasm.lua *
--brainfuck jit compiler for demoing DynASM Lua mode (Cosmin Apreutesei, public domain).
--adapted from http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html.

local ffi = require'ffi'
local dasm = require'dasm'

|.arch x86
|.actionlist actions
|.externnames externnames
|
|// Use ebx as our cell pointer.
|// Since ebx is a callee-saved register, it will be preserved
|// across our calls to getchar and putchar.
|.define PTR, ebx

return function(program)

	-- Create the dynasm state, supplying the externnames list
	-- we got from the preprocessor, which enables finding of extern symbols.
	local Dst = dasm.new(actions, externnames)

	local maxpc   = 0
	local maxtop  = 256
	local pcstack = ffi.new('int[?]', maxtop)
	local top     = 0

	-- Function prologue.
	|  push PTR
	|  mov  PTR, [esp+8]  // arg#1

	for c in string.gmatch(program, '.') do
		if c == '>' then
			|  inc  PTR
		elseif c == '<' then
			|  dec  PTR
		elseif c == '+' then
			|  inc  byte [PTR]
		elseif c == '-' then
			|  dec  byte [PTR]
		elseif c == '.' then
			|  push dword [PTR]
			|  call extern putchar
			|  add esp, 4
		elseif c == ',' then
			|  call extern getchar
			|  mov  byte [PTR], al
		elseif c == '[' then
			if top == maxtop then
				error'Nesting too deep.'
			end
			-- Each loop gets two pclabels: at the beginning and end.
			-- We store pclabel offsets in a stack to link the loop
			-- begin and end together.
			maxpc = maxpc + 2
			pcstack[top] = maxpc
			top = top + 1
			Dst:growpc(maxpc)
			|  cmp  byte [PTR], 0
			|  je   =>(maxpc-2)
			|=>(maxpc-1):
		elseif c == ']' then
			if top == 0 then
				error'Unmatched ]'
			end
			top = top - 1
			|  cmp  byte [PTR], 0
			|  jne  =>(pcstack[top]-1)
			|=>(pcstack[top]-2):
		end
	end

	-- Function epilogue.
	|  pop  PTR
	|  ret

	-- Link and encode the program.
	local buf = Dst:build()

	-- Take a function pointer to the top of the compiled program.
	local fptr = ffi.cast('void (*)(char*)', buf)
	-- Allocate the program's scratch memory.
	local cells = ffi.new('uint8_t[?]', 65536)
	-- Run the program, passing the addr of the scratch memory.
	fptr(cells)
end

